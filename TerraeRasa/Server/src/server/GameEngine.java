package server;

import io.Chunk;
import io.ChunkManager;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;

import transmission.ChunkCompressor;
import transmission.CompressedClientUpdate;
import transmission.EntityUpdate;
import transmission.ServerUpdate;
import transmission.UpdateWithObject;
import utils.ErrorUtils;
import utils.FileManager;
import world.World;
import entities.EntityPlayer;

/**
 * <code>GameEngine</code> is the class responsible for running the main game loop, and other core features of multiple worlds.
 * <code>GameEngine</code> defines 4 important methods. 
 * <br><br>
 * The method {@link #startGame(World, EntityPlayer)} defines the method to actually start the game with the specified World object
 * and player. This will close the main menu and begin rendering based on the Chunk data. 
 * <br><br>
 * Most of the application's life cycle is spent in {@link #run()} method, which contains the main game loop. This handles
 * everything from the main menu to the game, and save menu. Before exiting this method, {@link #saveSettings()} will be called
 * to update any settings changed during runtime. 
 * <br><br>
 * Additional methods of interest: <br>
 * {@link #changeWorld(int)}, {@link #closeGameToMenu()}
 *   
 * 
 * @author      Alec Sobeck
 * @author      Matthew Robertson
 * @version     1.0
 * @since       1.0
 */
public class GameEngine 
{
	private final Object serverCommandLock = new Object();
	private final Object clientUpdateLock = new Object();
	private final Object extraObjectUpdateLock = new Object();
	private final Object playersLock = new Object();
	private final Object chunkLock = new Object();
	private final Object extraTextUpdateLock = new Object();
	/** The number of game ticks per second - this will always be 20 */
	public static final int TICKS_PER_SECOND = 20;
	private World world;
	private Vector<EntityPlayer> players = new Vector<EntityPlayer>(10);
	private ChunkManager chunkManager;
	private String universeName;
	private List<String> pendingChunkRequests = new ArrayList<String>();
	private Vector<UpdateWithObject> extraObjectUpdates = new Vector<UpdateWithObject>();
	private Vector<EntityUpdate> extraEntityUpdates = new Vector<EntityUpdate>();
	/**Updates provided by a client that are not yet processed.*/
	private Vector<CompressedClientUpdate> clientUpdates = new Vector<CompressedClientUpdate>(); 
	private Vector<String> extraTextUpdates = new Vector<String>();
	/**Commands that are generated by the server and need processed. IE console commands. */
	private Vector<String> serverCommands = new Vector<String>();
	/**Clients which have requested a connection be terminated.*/
	
	/**
	 * Creates a new instance of GameEngine. This includes setting the renderMode to RENDER_MODE_WORLD_EARTH
	 * and loading the settings object from disk. If a settings object cannot be found a new one is created. 
	 */
	public GameEngine(String universeName)
	{
		this.universeName = universeName;
		this.chunkManager = new ChunkManager();
		this.getChunkManager().setUniverseName(universeName);
	}
	
	public void run()
	{
		try {
			loadWorld();			
			//Variables for the gameloop cap (20 times / second)	
			final int SKIP_TICKS = 1000 / TICKS_PER_SECOND;
			final int MAX_FRAMESKIP = 5;
			long next_game_tick = System.currentTimeMillis();
			long start;
			long end;
			int loops;
			start = System.currentTimeMillis();
			
			TerraeRasa.canAcceptConnections = true;
			
		    while(!TerraeRasa.done) //Main Game Loop
		    {
		        loops = 0;
		        while(System.currentTimeMillis() > next_game_tick && loops < MAX_FRAMESKIP) //Update the game 20 times/second 
		        {
//		        	if(player != null && player.defeated)
//		        	{
//		        		hardcoreDeath();
//		        	}	
		        	//TODO: hardcore
		        
		        	
		        	ServerUpdate update = new ServerUpdate();
		        	TerraeRasa.processCloseRequests();
		        	CompressedClientUpdate[] updates = yieldClientUpdates();
		        	processClientUpdates(update, updates);
		        	
		        	world.onWorldTick(update, players);
		        	for(EntityUpdate up : extraEntityUpdates)
		        	{
		        		update.addEntityUpdate(up);
		        	}
		        	extraEntityUpdates.clear();
		        	
		        	String[] values = yieldCommandUpdates();
		        	for(String val : values)
		        	{
		        		update.addValue(val);
		        	}
		        	
		        	UpdateWithObject[] objUpdates = yieldExtraObjectUpdates();
		        	for(UpdateWithObject object : objUpdates)
		        	{
		        		update.addObjectUpdate(object);
		        	}
		        	
		        	String[] serverCommands = yieldServerCommands();
		        	for(String val : serverCommands)
		        	{
		        		Commands.processConsoleCommand(TerraeRasa.terraeRasa.getSettings(), update, players, world, this, val);
		        	}
		        	
		        	Iterator<String> it = pendingChunkRequests.iterator();
		        	while(it.hasNext())
		        	{
		        		String request = it.next();
		        		String[] split = request.split(" ");
		        		
		        		if(world.chunksLoaded.get(split[3]))
						{
		        			UpdateWithObject objUpdate = new UpdateWithObject();
		        			objUpdate.command = "/chunk " + split[1]; 
		        			objUpdate.object = ChunkCompressor.compressChunk(world.getChunk(Integer.parseInt(split[3])));
							update.addObjectUpdate(objUpdate);
//							> TODO: ?Create a new update object and defer the compression of that object?
							it.remove();
						}
		        	}
		        	
		        	TerraeRasa.addWorldUpdate(update);
		        	
		        	next_game_tick += SKIP_TICKS;
 		            loops++;
		        }
		        
		        //Make sure the game loop doesn't fall very far behind and have to accelerate the 
		        //game for an extended period of time
		        if(System.currentTimeMillis() - next_game_tick > 1000)
		        {
		        	next_game_tick = System.currentTimeMillis();
		        }
		        if(System.currentTimeMillis() - start >= 5000)
		        {
		        	start = System.currentTimeMillis();
	        		end = System.currentTimeMillis();     
//	        		System.out.println(start - end);
		    	}
//	        	System.out.println(end - start);
		    }     
		} catch(Exception e) {
			//Fatal error catching
			e.printStackTrace();			
			ErrorUtils errorUtils = new ErrorUtils();
			errorUtils.writeErrorToFile(e, true);			
		} finally {
			world.saveRemainingWorld();
			TerraeRasa.done = true;
			TerraeRasa.close();
		}
	}	
	
	private void processClientUpdates(ServerUpdate serverUpdate, CompressedClientUpdate[] updates)
	{
		for(CompressedClientUpdate update : updates)
		{
			for(String command : update.commands)
			{
				String result = Commands.processClientCommand(serverUpdate, null, world, this, players, command, pendingChunkRequests);
				if(!result.equals(""))
				{
					addCommandUpdate(result);
				}
			}
			for(UpdateWithObject objUpdate : update.objectUpdates)
			{
				String result = Commands.processClientCommand(serverUpdate, objUpdate.object, world, this, players, objUpdate.command, pendingChunkRequests);
				if(!result.equals(""))
				{
					addCommandUpdate(result);
				}
			}
		}
	}
	
	/**
	 * Server commands are the various slash commands that the player or the console can issue. 
	 * @param player
	 * @param command
	 * @param consoleGenerated
	 */
	public  void registerServerCommand(EntityPlayer player, String command, boolean consoleGenerated)
	{
		synchronized(serverCommandLock)
		{
			//If a player issues a command with "console" level permission it fails. Likewise they need the
			//required mod/admin permission to issue one of those commands.
			if(player != null)
			{
				int commandTier = Commands.getCommandTier(command);
				if(commandTier == Commands.PERMISSION_CONSOLE)
				{
					serverCommands.add("/say YELLOW You do not have the required permissions to issue that command");
					return;
				}
				else if(commandTier == Commands.PERMISSION_ADMIN)
				{
					if(!player.isAdmin())
					{
						serverCommands.add("/say YELLOW You do not have the required permissions to issue that command");
						return;
					}
				}
				else if(commandTier == Commands.PERMISSION_MOD)
				{
					if(!player.isMod() && !player.isAdmin())
					{
						serverCommands.add("/say YELLOW You do not have the required permissions to issue that command");
						return;
					}
				}			
				serverCommands.add(command);
			}		
			else if(consoleGenerated)
			{
				serverCommands.add(command);
			}
		}
	}

	public String[] yieldServerCommands()
	{
		synchronized(serverCommandLock)
		{
			String[] updates = new String[serverCommands.size()];
			serverCommands.copyInto(updates);
			serverCommands.clear();
			return updates;
		}
	}
	
	public CompressedClientUpdate[] yieldClientUpdates()
	{
		synchronized(clientUpdateLock)
		{
			CompressedClientUpdate[] updates = new CompressedClientUpdate[clientUpdates.size()];
			clientUpdates.copyInto(updates);
			clientUpdates.clear();
			return updates;
		}
	}
	
	public void registerClientUpdate(CompressedClientUpdate update)
	{
		synchronized(clientUpdateLock)
		{
			clientUpdates.add(update);
		}
	}
	
	public World getWorld() {
		return world;
	}
		
	public String[] yieldCommandUpdates()
	{
		synchronized(extraTextUpdateLock)
		{
			String[] updates = new String[extraTextUpdates.size()];
			extraTextUpdates.copyInto(updates);
			extraTextUpdates.clear();
			return updates;
		}
	}
	
	public void addCommandUpdate(String command)
	{
		synchronized(extraTextUpdateLock)
		{
			extraTextUpdates.add(command);
		}
	}
	
	public UpdateWithObject[] yieldExtraObjectUpdates()
	{
		synchronized(extraObjectUpdateLock)
		{
			UpdateWithObject[] updates = new UpdateWithObject[extraObjectUpdates.size()];
			extraObjectUpdates.copyInto(updates);
			extraObjectUpdates.clear();
			return updates;
		}
	}
	
	public void addExtraObjectUpdate(UpdateWithObject update)
	{
		synchronized(extraObjectUpdateLock)
		{
			extraObjectUpdates.add(update);
		}
	}
	
	public EntityPlayer[] getPlayersArray()
	{
		synchronized(playersLock)
		{
			EntityPlayer[] players = new EntityPlayer[this.players.size()];
			this.players.copyInto(players);
			return players;
		}
	}
	
	public void registerPlayer(EntityPlayer player)
	{
		synchronized(playersLock)
		{
			players.add(player);
			EntityUpdate update = new EntityUpdate();
			update.entityID = player.entityID;
			update.updatedEntity = player.getTransmittable();
			update.action = 'a';
			update.type = 5;
			extraEntityUpdates.add(update);
			
			ServerSettings settings = TerraeRasa.terraeRasa.getSettings();
			
			if(settings.isAdmin(player.getAssociatedIP()))
			{
				player.setIsAdmin(true);
			}
			else if(settings.isMod(player.getAssociatedIP()))
			{
				player.setIsMod(true);
			}
			
			world.addPlayer(player);
		}
	}
	
	public void removePlayer(EntityPlayer player)
	{
		synchronized(playersLock)
		{
			players.remove(player);
			EntityUpdate update = new EntityUpdate();
			update.entityID = player.entityID;
			update.updatedEntity = null;
			update.action = 'r';
			update.type = 5;
			extraEntityUpdates.add(update);
			world.entitiesByID.remove(""+player.entityID);
			player = null;
		}
	}

	public Chunk requestChunk(int x)
	{
		synchronized(chunkLock)
		{
			Chunk chunk = world.getChunk(x);
			if(chunk == null)
			{
				world.forceloadChunk(x);
			}
			return chunk;
		}
	}
			
	/**
	 * Initiates a hardcore death - which deletes the player and exits to the main menu. For now.
	 */
	public void hardcoreDeath()
	{
		//Delete the player
//		FileManager manager = new FileManager();
//		manager.deletefile("/Player Saves/" + player.getName());
//		this.player = null;

		//Save the world
//		world.saveRemainingWorld();
		System.out.println("This doesnt do anything.");
		//TODO: Hardcore
	}
	
	/**
	 * @depreciated - this doesnt do anything and wouldnt work anyway.
	 * @param newMode the final integer value for the new world (indicating what object to manipulate)
	 * @throws IOException indicates a general failure to load the file, not relating to a version error
	 * @throws ClassNotFoundException indicates the saved world version is incompatible
	 */
	public void changeWorld(int newMode)
			throws IOException, ClassNotFoundException
	{
//		String worldName = "";
//		world.saveRemainingWorld();
//		world = null;
//		FileManager manager = new FileManager();
//		manager.loadWorld("Earth", worldName);
	}
	
	private void loadWorld()
	{
		File file = new File(TerraeRasa.getBasePath() + "/" + universeName);
		FileManager manager = new FileManager();
		if(file.exists())
		{
			try {
				this.world = manager.loadWorld("/Earth", universeName);
				this.world.chunkManager = this.getChunkManager();
			} catch (IOException e) {
				e.printStackTrace();
			} catch (ClassNotFoundException e) {
				e.printStackTrace();
			}
		}
		else
		{
			this.world = manager.generateAndSaveWorld(universeName, 
					TerraeRasa.terraeRasa.getSettings().worldSize, 
					TerraeRasa.terraeRasa.getSettings().worldDifficulty);
		}
		
		Log.log("Loaded Universe: " + universeName);
	}
	
	public EntityPlayer getPlayer(String playerName)
	{
		synchronized(playersLock)
		{
			Iterator<EntityPlayer> it = players.iterator();
			while(it.hasNext())
			{
				EntityPlayer player = it.next();
				if(player.getName().equalsIgnoreCase(playerName))
				{
					return player;
				}
			}
		}
		return null;
	}
	
	public void saveChunks()
	{
		synchronized(chunkLock)
		{
			getChunkManager().saveAllChunksWithoutUnload(universeName, world.getChunks());
		}
	}

	public ChunkManager getChunkManager() {
		return chunkManager;
	}
}